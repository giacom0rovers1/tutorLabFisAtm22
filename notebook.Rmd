---
title: "Wind processing with tidyverse - R Notebook"
output: html_notebook
---

## Esperienza 1 - Laboratorio di Fisica dell'Atmosfera A.A. 2022/23

**Autore**: Giacomo Roversi

------------------------------------------------------------------------

Per cominciare inizializziamo l'ambiente di calcolo: cancello eventuali variabili e carico i pacchetti necessari.

```{r}
# clear the workspace
rm(list=ls())
```

```{r}
# load packages
require(tidyverse)
require(lubridate)
```

------------------------------------------------------------------------

### Definizione dei nomi dei files e delle cartelle

Genero tutti i nomi dei vari output del progetto partendo dalla variabile "radice" che imposto qui. L'ho chiamata `StationDataRootName`. Dichiaro tutto all'inizio del codice per non dover andare poi in cerca dei nomi se volessi fare delle modifiche. Distribuisco i files in tre cartelle: `datafolder` conterrà solo i dati grezzi in input, da non modificare, `resfolder` conterrà tutti i dati processati e i risultati, `figfolder` le figure.

```{r}
# Define the project directories (relative path)
datafolder <- "Esp_1/dati/"
figfolder  <- "Esp_1/figure/"
resfolder  <- "Esp_1/risultati/"

# Define the input filenames and assign them to a variable
StationDataRootName <- "Dati Meteo - Stazione A"

filenames <- list(
  input           = paste0(datafolder, StationDataRootName, ".txt"),
  
  output.proc     = paste0(resfolder , StationDataRootName, "_proc.txt"),
  output.ExcTIME  = paste0(resfolder , StationDataRootName, "_ExcTIME.txt"),
  output.ExcWSneg = paste0(resfolder , StationDataRootName, "_ExcWSneg.txt"),
  ouput.ExcWS3h   = paste0(resfolder , StationDataRootName, "_ExcWS3h.txt"),
  output.LAKES    = paste0(resfolder , StationDataRootName, "_LAKES.txt"),
  
  figure.DataConsistency = paste0(figfolder, StationDataRootName, "_DataConsistency.png"),
  figure.HistWS          = paste0(figfolder, StationDataRootName, "_HistWS.png"),
  figure.WindRose        = paste0(figfolder, StationDataRootName, "_WindRose.png"),
  figure.ScatterPlot     = paste0(figfolder, StationDataRootName, "_ScatterPlot.png"),
  figure.DailyWind       = paste0(figfolder, StationDataRootName, "_DailyWind.png")
)
```

------------------------------------------------------------------------

### Correzione dell'intestazione dei files di dati delle stazioni Davis

Leggo la prima riga e la spezzo dove ci sono le virgole, poi processo il risultato attraverso vari passaggi di sostituzione caratteri in modo da eliminare il cancelletto a inizio riga e i vari spazi vuoti rimasti. Salvo il tutto nella variabile "header", che mi servirà tra poco.

```{r}
connection <- file(filenames$input)
open(connection)

header <- strsplit(readLines(connection, 1), ",")[[1]] %>% 
  str_replace("#", "")     %>%   
  str_replace("     ", "") %>%
  str_replace("    ", "")  %>%
  str_replace("   ", "")   %>%
  str_replace(" ", "")     %>%
  str_replace(" ", "")

close(connection)

```

**Nota 1.** L'operatore `%>%` concatena l'output di una funzione come input della successiva (come l'operatore "pipe" `|` in bash ad esempio) . Solo le funzioni del pacchetto `tidyverse` sono predisposte per accettare questa concatenazione in input. Le funzioni base di R invece sono utilizzate nella prima riga nella classica forma innestata ("nested"), ovvero una dentro l'altra.

**Nota 2.** La funzione `strsplit()` restituisce come output una **lista** (vedi `?list`). La lista ha un solo elemento, costituito da un vettore di stringhe di caratteri, che sarebbero i vari pezzi in cui è stata suddivisa la prima riga del nostro file di input. Il suffisso `[[1]]` che compare dopo `strsplit()` serve a selezionare direttamente il vettore caratteri contenuto nella prima posizione della lista, invece che tutta la lista, che non sarebbe un input corretto per `str_replace()`.

------------------------------------------------------------------------

### Lettura intelligente del file dei dati

Tramite il pacchetto `readr` (incluso in `tidyerse`), le colonne "Date" e "Time" possono essere già importate rispettivamente come date e orari (formati specifici). In questo modo facilitiamo le operazioni sugli intervalli temporali (i giorni del calendario e le ore del giorno vengono gestite in automatico).

Il metodo di definizione dei nomi delle variabili (colonne) è robusto perché ho preso i nomi direttamente dal file originale (variabile `header` assegnata a `col_names`), quindi non rischio di sbagliare l'ordine definendole manualmente. Se nel file di input cambiassero ad esempio l'ordine o il numero delle colonne, la nostra tabella si adeguerebbe in automatico (nel limite che il file non cambi così tanto da invalidare le convenzioni alla base della correzione al punto precedente).

```{r}
# READING DATA
StationData <- read_table(filenames$input,
                            col_types = list(                        
                              Date = col_datetime(format = "%Y%m%d"),  
                              Time = col_time(format = "%H.%M")
                            ),
                          comment = "#",
                          col_names = header)
StationData %>% head()
```

I dati vengono salvati direttamente in una "*tibble*", che è un "*data.frame*" - ma potenziato - che costituisce la struttura dati di base del pacchetto `tidyr` di `tidyverse`. L'output nel terminale è già tagliato in modo da non occupare troppe righe e sono incluse informazioni sui formati delle varie colonne. La visualizzazione è interattiva e permettere di scorrere verso destra per vedere le colonne oltre la decima.

------------------------------------------------------------------------

### Variabili aggiuntive di supporto

Aggiungo colonne di supporto, non deve preoccuparmi la ridondanza, la memoria viene comunque gestita in modo efficiente a questo livello. Unisco data e ora nella colonna `DateTime`.

```{r}
StationData$DateTime <- StationData$Date + StationData$Time
```

Poi creo una colonna di "factors" (vedi `?factor`) per la divisione in stagioni meteorologiche.

```{r}
# creo un vettore caratteri vuoto, della dimensione delle righe di StationData
Season <- character(length = length(StationData$DateTime))

Season[which(month(StationData$DateTime) %in% c(12, 1:2))] <- "DJF"
Season[which(month(StationData$DateTime) %in% 3:5)]        <- "MAM"
Season[which(month(StationData$DateTime) %in% 6:8)]        <- "JJA"
Season[which(month(StationData$DateTime) %in% 9:11)]       <- "SON"

StationData$Season <- factor(Season)
```

Posso ripetere lo stesso procedimento per dividere ad esempio in momenti della giornata.

------------------------------------------------------------------------

### Grafici esplorativi

La funzione `geom_histogram()` crea un istogramma della variabile specificata in `aes()`. Il parametro aggiuntivo fill dentro `aes()` permettere di suddividere le colonne dell'istogramma per stagione, andando a differenziare il colore di riempimento ("fill" appunto).

```{r}
StationData %>%
  ggplot(aes(year(DateTime), fill = Season)) + 
  geom_histogram(binwidth = 1) + 
  theme_bw()
```

La funzione `geom_count()` è utile per scatterplots e simili, dove c'è rischio concreto di overplotting.

```{r}
# Un esempio di grafico con la suite ggplot2 preceduta da un filtro
StationData %>%
  filter(
    Press > 800,
    outTemp > -30,
    outHum > 0,
    totRad > 0
  ) %>%
ggplot(aes(hour(Time), wndSpeed, color = Season)) + 
  geom_count() +
  # geom_point() +                    # issue: overplotting
  # geom_boxplot() +                  # dovrei cambiare la variabile in x
  facet_wrap(~Season) +               # divido in quattro box
  coord_cartesian(ylim = c(0, 10)) +  # taglio alcuni valori estremi
  theme_bw()

# si potrebbero cambiare i colori e l'ordine delle stagioni!
```

Lo stesso grafico, usando però `geom_point()` che è affetto da overplotting. Non si capisce quali punti siano più popolati e il rendering della figura è molto rallentato (vengono disegnati inutilmente tantissimi punti).

```{r}
StationData %>%
  filter(
    Press > 800,
    outTemp > -30,
    outHum > 0,
    totRad > 0
  ) %>%
ggplot(aes(hour(Time), wndSpeed, color = Season)) + 
  geom_point() +                    # issue: overplotting
  # geom_boxplot() +                  # dovrei cambiare la variabile in x
  facet_wrap(~Season) +               # divido in quattro box
  coord_cartesian(ylim = c(0, 10)) +  # taglio alcuni valori estremi
  theme_bw()

```

Continua...
