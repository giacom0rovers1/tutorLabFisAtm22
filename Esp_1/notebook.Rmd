---
title: "Wind processing with tidyverse - R Notebook"
output: html_notebook
---

## Esperienza 1 - Laboratorio di Fisica dell'Atmosfera A.A. 2022/23

**Autore**: Giacomo Roversi

------------------------------------------------------------------------

Per cominciare inizializziamo l'ambiente di calcolo: cancello eventuali variabili e carico i pacchetti necessari.

```{r}
# Clear the workspace
rm(list=ls())
```

```{r}
# Load packages
require(tidyverse)
require(zoo)

# To see what packages are part of tidyverse:
tidyverse_logo()
tidyverse_packages()

```

```{r}
# Define the working directory (in this case, the path is different depending on whether the code is executed on Linux or Windows, but just for my convenience)
if(Sys.info()["sysname"]=="Linux"){
  setwd("/home/giacom0rovers1/tutorLabFisAtm22/Esp_1/")
}else{
  setwd("C:/projects/tutorLabFisAtm22/Esp_1/")
}
```

------------------------------------------------------------------------

### Definizione dei nomi dei files e delle cartelle

Genero tutti i nomi dei vari output del progetto partendo dalla variabile "radice" che imposto qui. L'ho chiamata `StationDataRootName`. Dichiaro tutto all'inizio del codice per non dover andare poi in cerca dei nomi se volessi fare delle modifiche. Distribuisco i files in tre cartelle: `datafolder` conterrà solo i dati grezzi in input, da non modificare, `resfolder` conterrà tutti i dati processati e i risultati, `figfolder` le figure.

```{r}
# Define the project directories (relative path)
datafolder <- "dati/"
figfolder  <- "figure/"
resfolder  <- "risultati/"

# Create the project directories, if missing
if(!dir.exists(datafolder)){ dir.create(datafolder) }
if(!dir.exists(figfolder)){  dir.create(figfolder) }
if(!dir.exists(resfolder)){  dir.create(resfolder) }

# Define the input filenames and assign them to a variable
StationDataRootName <- "Dati Meteo - Stazione A"

filenames <- list(
  input           = paste0(datafolder, StationDataRootName, ".txt"),
  
  # output.proc     = paste0(resfolder , StationDataRootName, "_proc.txt"),
  # output.ExcTIME  = paste0(resfolder , StationDataRootName, "_ExcTIME.txt"),
  # output.ExcWSneg = paste0(resfolder , StationDataRootName, "_ExcWSneg.txt"),
  # ouput.ExcWS3h   = paste0(resfolder , StationDataRootName, "_ExcWS3h.txt"),
  output.LAKES    = paste0(resfolder , StationDataRootName, "_LAKES.txt"),
  
  figure.DataConsistency = paste0(figfolder, StationDataRootName, "_DataConsistency.png"),
  figure.HistWS          = paste0(figfolder, StationDataRootName, "_HistWS.png"),
  figure.WindRose        = paste0(figfolder, StationDataRootName, "_WindRose.png"),
  figure.ScatterPlot     = paste0(figfolder, StationDataRootName, "_ScatterPlot.png"),
  figure.DailyWind       = paste0(figfolder, StationDataRootName, "_DailyWind.png")
)
```
Gli outputs su file leggibile (txt, csv) hanno senso solo se dobbiamo interfacciare linguaggi o software diversi, come nel caso di WRPLOT di Lakes, altrimenti conviene salvare i dati in un archivio dati compresso (in R hanno l'estensione `.RData`, equivalenti ad esempio ai `.mat` di Matlab.).


------------------------------------------------------------------------

### Correzione dell'intestazione dei files di dati delle stazioni Davis

Leggo la prima riga e la spezzo dove ci sono le virgole, poi processo il risultato attraverso vari passaggi di sostituzione caratteri in modo da eliminare il cancelletto a inizio riga e i vari spazi vuoti rimasti. Salvo il tutto nella variabile "header", che mi servirà tra poco.

```{r}
connection <- file(filenames$input)
open(connection)

header <- strsplit(readLines(connection, 1), ",")[[1]] %>% 
  str_replace("#", "")     %>%   
  str_replace("     ", "") %>%
  str_replace("    ", "")  %>%
  str_replace("   ", "")   %>%
  str_replace(" ", "")     %>%
  str_replace(" ", "")

close(connection)

```

**Nota 1.** L'operatore `%>%` concatena l'output di una funzione come input della successiva (come l'operatore "pipe" `|` in bash ad esempio) . Solo le funzioni del pacchetto `tidyverse` sono predisposte per accettare questa concatenazione in input. Le funzioni base di R invece sono utilizzate nella prima riga nella classica forma innestata ("nested"), ovvero una dentro l'altra.

**Nota 2.** La funzione `strsplit()` restituisce come output una **lista** (vedi `?list`). La lista ha un solo elemento, costituito da un vettore di stringhe di caratteri, che sarebbero i vari pezzi in cui è stata suddivisa la prima riga del nostro file di input. Il suffisso `[[1]]` che compare dopo `strsplit()` serve a selezionare direttamente il vettore caratteri contenuto nella prima posizione della lista, invece che tutta la lista, che non sarebbe un input corretto per `str_replace()`.

------------------------------------------------------------------------

### Lettura intelligente del file dei dati

Tramite il pacchetto `readr` (incluso in `tidyerse`), le colonne "Date" e "Time" possono essere già importate rispettivamente come date e orari (formati specifici). In questo modo facilitiamo le operazioni sugli intervalli temporali (i giorni del calendario e le ore del giorno vengono gestite in automatico).

Il metodo di definizione dei nomi delle variabili (colonne) è robusto perché ho preso i nomi direttamente dal file originale (variabile `header` assegnata a `col_names`), quindi non rischio di sbagliare l'ordine definendole manualmente. Se nel file di input cambiassero ad esempio l'ordine o il numero delle colonne, la nostra tabella si adeguerebbe in automatico (nel limite che il file non cambi così tanto da invalidare le convenzioni alla base della correzione al punto precedente).

```{r}
# READING DATA
StationData <- read_table(filenames$input,
                          col_types = list(                        
                            Date = col_datetime(format = "%Y%m%d"),  
                            Time = col_time(format = "%H.%M")
                          ),
                          comment = "#",
                          col_names = header)
print(StationData) #%>% head()
```

I dati vengono salvati direttamente in una "*tibble*", che è un "*data.frame*" - ma potenziato - che costituisce la struttura dati di base del pacchetto `tidyr` di `tidyverse`. L'output nel terminale è già tagliato in modo da non occupare troppe righe e sono incluse informazioni sui formati delle varie colonne. La visualizzazione è interattiva e permettere di scorrere verso destra per vedere le colonne oltre la decima.

------------------------------------------------------------------------

### Variabili aggiuntive di supporto

Aggiungo colonne di supporto, non deve preoccuparmi la ridondanza, la memoria viene comunque gestita in modo efficiente a questo livello. Unisco data e ora nella colonna "DateTime".

```{r}
StationData$DateTime <- StationData$Date + StationData$Time
head(StationData[,c("Date", "Time", "DateTime", "Interval", "Press")])
```

Poi creo una colonna di "factors" per la divisione in stagioni meteorologiche. I factor sono un formato di variabili in R, sono delle etichette predisposte per acquisire solo valori preimpostati, detti "livelli" (vedi `?factor`).

```{r}
# creo un vettore caratteri vuoto, della dimensione delle righe di StationData
Season <- character(length = length(StationData$DateTime))

Season[which(month(StationData$DateTime) %in% c(12, 1:2))] <- "DJF"
Season[which(month(StationData$DateTime) %in% 3:5)]        <- "MAM"
Season[which(month(StationData$DateTime) %in% 6:8)]        <- "JJA"
Season[which(month(StationData$DateTime) %in% 9:11)]       <- "SON"

StationData$Season <- factor(Season, levels = c("DJF", "MAM", "JJA", "SON"))
```

**Attenzione!**

1.  Le misure non sono ordinate temporalmente. Uso la nuova colonna per riordinarle:
```{r}
StationData <- StationData[order(StationData$"DateTime"),]
head(StationData[,c("Date", "Time", "DateTime", "Interval", "Press")])

```

2.  Nel dataset convivono misure a diversi intervalli temporali. Lo vedo cercando i diversi valori che acquisisce la variabile "Interval":
```{r}
unique(StationData$Interval)
StationData[which(StationData$Interval == 1),]
```

------------------------------------------------------------------------

### Grafici esplorativi

Come si distribuiscono le diverse risoluzioni temporali?
```{r}
# istogramma con le funzioni base di R
hist(StationData$Interval)

```

Quando troviamo dati con risoluzione al minuto?

```{r}
# istogramma con le funzioni ggplot della suite tidyverse
StationData %>% 
  filter(
    Interval == 1
  ) %>% 
  ggplot(aes(DateTime)) +
  geom_histogram(bins = 30, 
                 fill='lightgrey', 
                 color='black') + 
  theme_classic()

```

La funzione `geom_histogram()` crea un istogramma della variabile specificata in `aes()`. Il parametro aggiuntivo fill dentro `aes()` permettere di suddividere le colonne dell'istogramma per stagione, andando a differenziare il colore di riempimento ("fill" appunto).
```{r}
StationData %>%
  ggplot(aes(year(DateTime), fill = Season)) + 
  geom_histogram(binwidth = 1) +
  scale_fill_manual(values = c("DJF" = "dodgerblue1",
                               "MAM" = "springgreen3",
                               "JJA" = "goldenrod1",
                               "SON" = "indianred1")) +
  # more colors at https://r-charts.com/colors/ 
  theme_bw()
```

La funzione `geom_count()` è utile per scatterplots e simili, dove c'è rischio concreto di overplotting.

```{r}
# Un esempio di grafico con la suite ggplot2 preceduta da un filtro
StationData %>%
  filter(
    Press > 800,
    outTemp > -30,
    outHum > 0,
    totRad > 0
  ) %>%
  ggplot(aes(hour(Time), wndSpeed, color = Season)) + 
  geom_count() +
  # geom_point() +                    # issue: overplotting
  # geom_boxplot() +                  # dovrei cambiare la variabile in x
  facet_wrap(~Season) +               # divido in quattro box
  coord_cartesian(ylim = c(0, 10)) +  # taglio alcuni valori estremi
  
  scale_color_manual(values = c("DJF" = "dodgerblue1",
                                "MAM" = "springgreen3",
                                "JJA" = "goldenrod1",
                                "SON" = "indianred1")) +
  theme_bw()

```

Lo stesso grafico, usando però `geom_point()` che è affetto da overplotting. Non si capisce quali punti siano più popolati e il rendering della figura è molto rallentato (vengono disegnati inutilmente tantissimi punti).

```{r}
StationData %>%
  filter(
    Press > 800,
    outTemp > -30,
    outHum > 0,
    totRad > 0
  ) %>%
  ggplot(aes(hour(Time), wndSpeed, color = Season)) + 
  geom_point() +                    # issue: overplotting
  # geom_boxplot() +                  # dovrei cambiare la variabile in x
  facet_wrap(~Season) +               # divido in quattro box
  
  scale_color_manual(values = c("DJF" = "dodgerblue1",
                                "MAM" = "springgreen3",
                                "JJA" = "goldenrod1",
                                "SON" = "indianred1")) +
  
  coord_cartesian(ylim = c(0, 10)) +  # taglio alcuni valori estremi
  theme_bw()

```

Scatterplot che mette tre variabili a confronto...

```{r}
StationData %>% 
  filter(
    wndSpeed >= 0, 
    outHum >=0, 
    outTemp > -50,
    inTemp > 0,
    totRad >=0
  ) %>% 
  ggplot(aes(totRad, outHum-inHum, color = outTemp-inTemp)) +
  geom_count() +
  facet_wrap(~Season) +
  scale_color_gradient2() + 
  # coord_cartesian(xlim = c(0,100)) + 
  # coord_fixed(
  #   xlim=c(0,20),
  #   ylim=c(0,20)
  #   ) +
  theme_bw()

```

### 

------------------------------------------------------------------------

### Filtri

Tramite la funzione `filter()` del pacchetto `dplyr` (sempre di tidyverse) posso creare filtri ponendo condizioni direttamente sulle colonne del dataset originale.

Tramite la funzione `minute()` del pacchetto `lubridate()` seleziono solo le righe prese allo scadere dell'ora.

Salvo un sottoinsieme del dataset in una nuova variabile, raccogliendo solo i dati orari. Attenzione perché la variabile "Interval" rimane impostata sulla risoluzione temporale originaria. Voglio solo misure orarie provenienti dalle letture ogni 30 minuti quindi richiedo anche che Interval == 30.

```{r}
HourlyData <- StationData %>%
  filter(
    minute(DateTime) == 0,
    Interval == 30
  )

print(HourlyData)
```

Per salvare il dataset di tutte le righe escluse posso usare nuovamente filter stando attento di impostare i filtri in modo complementare, oppure posso usare la funzione `setdiff()` di `dplyr`. Dichiaro l'appartenenza al pacchetto in modo esplicito per essere sicuro che non ci siano ambiguità nel caso di più funzioni con lo stesso nome.

```{r}
excludedData <- dplyr::setdiff(StationData, HourlyData)
print(excludedData)
```



Imposto gli estremi dell'intervallo temporale di interesse tramite la funzione `as.POSIXct`, specificando il formato in cui fornisco la stringa e il fuso orario (IMPORTANTE! di default verrebbe registrato come CET, meglio lavorare in UTC imho).
```{r}
# Uso le funzioni base:
startTime <- as.POSIXct("201401010030", format = "%Y%m%d%H%M", tz = "UTC")
endTime   <- as.POSIXct("201701010000", format = "%Y%m%d%H%M", tz = "UTC")

# oppure quelle offerte dal pacchetto lubridate di tidyverse:
ymd_hm("201401010030")
ymd_hm("201701010000")

```



Filtro i valori non verosimili della velocità del vento per l'intervallo prescelto.

```{r}
windData <- StationData %>%
  filter(
    DateTime >= startTime,
    DateTime <  endTime,
    
    Interval == 30, # seleziono solo misure a 30 minuti
    
    wndSpeed >= 0,
    wndSpeed <= 25,
    
    wndDir >= 0,
    wndDir <= 360
    
    # ovviamente in questo comando posso inserire anche una selezione dell'intervallo temporale, andando ad impostare un minimo ed un massimo per DateTime
    
  )%>%
  select(DateTime, wndDir, wndSpeed, Season)

print(windData)
```


Elimino gli istanti in cui il vento non è nullo e non cambia per tre ore consecutive (indice di probabile malfunzionamento dello strumento). Per farlo evito di usare `if` e `for` concatenati. Piuttosto creo dei flag di supporto tramite funzioni ottimizzate a finestra mobile (dal pacchetto  `zoo`).

```{r}
# flag di continuità per 3 ore consecutive: (align = "left")
Diff3hL <- c(as.double(diff(windData$DateTime,lag = 5)), rep(NA, 5))

# flag di continuità per 3 ore consecutive: (align = "right")
Diff3hR <- c(rep(NA, 5), as.double(diff(windData$DateTime,lag = 5)))

windData$whole3hours <- Diff3hL == 2.5 | Diff3hR == 2.5



# flag di costanza della velocità in 3 ore (align = "left")
DiffWsL <- rollapply(windData$wndSpeed,
                     width = 6, by=1,
                     FUN = sd,
                     align = "left",
                     fill  = NA)

# flag di costanza della velocità in 3 ore (align = "right")
DiffWsR <- rollapply(windData$wndSpeed,
                     width = 6, by=1,
                     FUN = sd,
                     align = "right",
                     fill  = NA)


windData$constFlag <- DiffWsL == 0 | DiffWsR == 0 


windData_excl <- windData %>% filter(
  wndSpeed > 0,
  constFlag == T,
  whole3hours == T
) %>% print()

windData_filtered <- setdiff(windData, windData_excl)
print(windData_filtered)

```


Salvo i dataset per poterli recuperare successivamente:

```{r}

save(windData_filtered, windData_excl, file = paste0(resfolder, "windData.RData"))
```
Il file `.RData` pesa molto meno dei files txt o csv e viene letto e scritto più rapidamente.



Visualizzo un istogramma delle velocità:
```{r}
windData_filtered %>%
  ggplot(aes(wndSpeed)) + 
  geom_histogram(binwidth = 0.5,
                 fill='lightgrey', 
                 color='black') +
  # scale_y_log10() +
  theme_bw()


```



Visualizzo un istogramma della "consistency":

```{r}
totalTime <- seq(startTime, endTime, by="30 min")

monthsTotIntervals <- hist(month(totalTime), plot = F, breaks = 0.5:12.5)
monthsPopulated    <- hist(month(windData_filtered$DateTime), plot = F, breaks = 0.5:12.5)

plot(monthsPopulated$mids, 100*monthsPopulated$counts/monthsTotIntervals$counts, type="h",
     xlim = c(0,12),
     ylim = c(0,100),
     # lwd = 10,
     xlab = "Month",
     ylab = "Valid data (%)")


df <- tibble(Months = monthsPopulated$mids, 
             `Valid data (%)` = 100*monthsPopulated$counts/monthsTotIntervals$counts)

df %>%
  ggplot(aes(Months, `Valid data (%)` )) + 
  geom_col(fill='lightgrey', 
           color='black') +
  theme_bw() 

```





Esporto i dati nel formato "LAKES":
```{r}
# EXPORT TO LAKE FORMAT ======================================

toLAKES <- cbind(matrix(
  rep(99999,dim(windData_filtered)[1]),dim(windData_filtered)[1],1), # Station ID (flag)
  
  year(windData_filtered$DateTime),                                  # Date (year, month, day, hour)
  month(windData_filtered$DateTime),
  day(windData_filtered$DateTime),
  hour(windData_filtered$DateTime),
  
  round(windData_filtered$wndDir,digits=0),                          # Rounded Wind Direction (?)
  round(1.94384*windData_filtered$wndSpeed,digits=0)                 # Rounded Wind Speed (knot = 1.94384 x m/s)
)
colnames(toLAKES) <- c("StID","YYYY","MM","DD","HH","Dir","WS")
rownames(toLAKES) <- c(1:dim(windData_filtered)[1])

windData_filtered[1:6,]
toLAKES[1:6,]



#this section added to append the "LAKES FORMAT" string at the beginning of the file
fileConn<-file(paste0(StationDataRootName,"_LAKES.txt"))
writeLines(c("LAKES FORMAT"), fileConn)
close(fileConn)

write.table(toLAKES, paste0(StationDataRootName,"_LAKES.txt"),
            sep = " ", row.names=FALSE, col.names=FALSE, append =TRUE)

```




