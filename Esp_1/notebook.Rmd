---
title: "Wind processing with tidyverse - R Notebook"
output: html_notebook
---

## Esperienza 1 - Laboratorio di Fisica dell'Atmosfera A.A. 2022/23

**Autore**: Giacomo Roversi

------------------------------------------------------------------------

Per cominciare inizializziamo l'ambiente di calcolo: cancello eventuali variabili e carico i pacchetti necessari.

```{r}
# clear the workspace
rm(list=ls())
```

```{r}
# load packages
require(tidyverse)
require(lubridate)
require(zoo)
```

------------------------------------------------------------------------

### Definizione dei nomi dei files e delle cartelle

Genero tutti i nomi dei vari output del progetto partendo dalla variabile "radice" che imposto qui. L'ho chiamata `StationDataRootName`. Dichiaro tutto all'inizio del codice per non dover andare poi in cerca dei nomi se volessi fare delle modifiche. Distribuisco i files in tre cartelle: `datafolder` conterrà solo i dati grezzi in input, da non modificare, `resfolder` conterrà tutti i dati processati e i risultati, `figfolder` le figure.

```{r}
# Define the project directories (relative path)
datafolder <- "Esp_1/dati/"
figfolder  <- "Esp_1/figure/"
resfolder  <- "Esp_1/risultati/"

# Create the project directories, if missing
if(!dir.exists(datafolder)){ dir.create(datafolder) }
if(!dir.exists(figfolder)){  dir.create(figfolder) }
if(!dir.exists(resfolder)){  dir.create(resfolder) }

# Define the input filenames and assign them to a variable
StationDataRootName <- "Dati Meteo - Stazione A"

filenames <- list(
  input           = paste0(datafolder, StationDataRootName, ".txt"),
  
  # output.proc     = paste0(resfolder , StationDataRootName, "_proc.txt"),
  # output.ExcTIME  = paste0(resfolder , StationDataRootName, "_ExcTIME.txt"),
  # output.ExcWSneg = paste0(resfolder , StationDataRootName, "_ExcWSneg.txt"),
  # ouput.ExcWS3h   = paste0(resfolder , StationDataRootName, "_ExcWS3h.txt"),
  output.LAKES    = paste0(resfolder , StationDataRootName, "_LAKES.txt"),
  
  figure.DataConsistency = paste0(figfolder, StationDataRootName, "_DataConsistency.png"),
  figure.HistWS          = paste0(figfolder, StationDataRootName, "_HistWS.png"),
  figure.WindRose        = paste0(figfolder, StationDataRootName, "_WindRose.png"),
  figure.ScatterPlot     = paste0(figfolder, StationDataRootName, "_ScatterPlot.png"),
  figure.DailyWind       = paste0(figfolder, StationDataRootName, "_DailyWind.png")
)
```

------------------------------------------------------------------------

### Correzione dell'intestazione dei files di dati delle stazioni Davis

Leggo la prima riga e la spezzo dove ci sono le virgole, poi processo il risultato attraverso vari passaggi di sostituzione caratteri in modo da eliminare il cancelletto a inizio riga e i vari spazi vuoti rimasti. Salvo il tutto nella variabile "header", che mi servirà tra poco.

```{r}
connection <- file(filenames$input)
open(connection)

header <- strsplit(readLines(connection, 1), ",")[[1]] %>% 
  str_replace("#", "")     %>%   
  str_replace("     ", "") %>%
  str_replace("    ", "")  %>%
  str_replace("   ", "")   %>%
  str_replace(" ", "")     %>%
  str_replace(" ", "")

close(connection)

```

**Nota 1.** L'operatore `%>%` concatena l'output di una funzione come input della successiva (come l'operatore "pipe" `|` in bash ad esempio) . Solo le funzioni del pacchetto `tidyverse` sono predisposte per accettare questa concatenazione in input. Le funzioni base di R invece sono utilizzate nella prima riga nella classica forma innestata ("nested"), ovvero una dentro l'altra.

**Nota 2.** La funzione `strsplit()` restituisce come output una **lista** (vedi `?list`). La lista ha un solo elemento, costituito da un vettore di stringhe di caratteri, che sarebbero i vari pezzi in cui è stata suddivisa la prima riga del nostro file di input. Il suffisso `[[1]]` che compare dopo `strsplit()` serve a selezionare direttamente il vettore caratteri contenuto nella prima posizione della lista, invece che tutta la lista, che non sarebbe un input corretto per `str_replace()`.

------------------------------------------------------------------------

### Lettura intelligente del file dei dati

Tramite il pacchetto `readr` (incluso in `tidyerse`), le colonne "Date" e "Time" possono essere già importate rispettivamente come date e orari (formati specifici). In questo modo facilitiamo le operazioni sugli intervalli temporali (i giorni del calendario e le ore del giorno vengono gestite in automatico).

Il metodo di definizione dei nomi delle variabili (colonne) è robusto perché ho preso i nomi direttamente dal file originale (variabile `header` assegnata a `col_names`), quindi non rischio di sbagliare l'ordine definendole manualmente. Se nel file di input cambiassero ad esempio l'ordine o il numero delle colonne, la nostra tabella si adeguerebbe in automatico (nel limite che il file non cambi così tanto da invalidare le convenzioni alla base della correzione al punto precedente).

```{r}
# READING DATA
StationData <- read_table(filenames$input,
                          col_types = list(                        
                            Date = col_datetime(format = "%Y%m%d"),  
                            Time = col_time(format = "%H.%M")
                          ),
                          comment = "#",
                          col_names = header)
print(StationData) #%>% head()
```

I dati vengono salvati direttamente in una "*tibble*", che è un "*data.frame*" - ma potenziato - che costituisce la struttura dati di base del pacchetto `tidyr` di `tidyverse`. L'output nel terminale è già tagliato in modo da non occupare troppe righe e sono incluse informazioni sui formati delle varie colonne. La visualizzazione è interattiva e permettere di scorrere verso destra per vedere le colonne oltre la decima.

------------------------------------------------------------------------

### Variabili aggiuntive di supporto

Aggiungo colonne di supporto, non deve preoccuparmi la ridondanza, la memoria viene comunque gestita in modo efficiente a questo livello. Unisco data e ora nella colonna "DateTime".

```{r}
StationData$DateTime <- StationData$Date + StationData$Time
head(StationData[,c("Date", "Time", "DateTime", "Interval", "Press")])
```

Poi creo una colonna di "factors" per la divisione in stagioni meteorologiche. I factor sono un formato di variabili in R, sono delle etichette predisposte per acquisire solo valori preimpostati, detti "livelli" (vedi `?factor`).

```{r}
# creo un vettore caratteri vuoto, della dimensione delle righe di StationData
Season <- character(length = length(StationData$DateTime))

Season[which(month(StationData$DateTime) %in% c(12, 1:2))] <- "DJF"
Season[which(month(StationData$DateTime) %in% 3:5)]        <- "MAM"
Season[which(month(StationData$DateTime) %in% 6:8)]        <- "JJA"
Season[which(month(StationData$DateTime) %in% 9:11)]       <- "SON"

StationData$Season <- factor(Season, levels = c("DJF", "MAM", "JJA", "SON"))
```

**Attenzione!**

1.  Le misure non sono ordinate temporalmente. Uso la nuova colonna per riordinarle:
```{r}
StationData <- StationData[order(StationData$"DateTime"),]
head(StationData[,c("Date", "Time", "DateTime", "Interval", "Press")])

```

2.  Nel dataset convivono misure a diversi intervalli temporali. Lo vedo cercando i diversi valori che acquisisce la variabile "Interval":
```{r}
unique(StationData$Interval)
StationData[which(StationData$Interval == 1),]
```

------------------------------------------------------------------------

### Grafici esplorativi

Come si distribuiscono le diverse risoluzioni temporali?
```{r}
# istogramma con le funzioni base di R
hist(StationData$Interval)

```

Quando abbiamo dati al minuto?

```{r}
# istogramma con le funzioni ggplot della suite tidyverse
StationData %>% 
  filter(
    Interval == 1
  ) %>% 
  ggplot(aes(DateTime)) +
  geom_histogram(bins = 30, 
                 fill='lightgrey', 
                 color='black') + 
  theme_classic()

```

La funzione `geom_histogram()` crea un istogramma della variabile specificata in `aes()`. Il parametro aggiuntivo fill dentro `aes()` permettere di suddividere le colonne dell'istogramma per stagione, andando a differenziare il colore di riempimento ("fill" appunto).
```{r}
StationData %>%
  ggplot(aes(year(DateTime), fill = Season)) + 
  geom_histogram(binwidth = 1) + 
  theme_bw()
```

La funzione `geom_count()` è utile per scatterplots e simili, dove c'è rischio concreto di overplotting.

```{r}
# Un esempio di grafico con la suite ggplot2 preceduta da un filtro
StationData %>%
  filter(
    Press > 800,
    outTemp > -30,
    outHum > 0,
    totRad > 0
  ) %>%
  ggplot(aes(hour(Time), wndSpeed, color = Season)) + 
  geom_count() +
  # geom_point() +                    # issue: overplotting
  # geom_boxplot() +                  # dovrei cambiare la variabile in x
  facet_wrap(~Season) +               # divido in quattro box
  coord_cartesian(ylim = c(0, 10)) +  # taglio alcuni valori estremi
  theme_bw()

```

Lo stesso grafico, usando però `geom_point()` che è affetto da overplotting. Non si capisce quali punti siano più popolati e il rendering della figura è molto rallentato (vengono disegnati inutilmente tantissimi punti).

```{r}
StationData %>%
  filter(
    Press > 800,
    outTemp > -30,
    outHum > 0,
    totRad > 0
  ) %>%
  ggplot(aes(hour(Time), wndSpeed, color = Season)) + 
  geom_point() +                    # issue: overplotting
  # geom_boxplot() +                  # dovrei cambiare la variabile in x
  facet_wrap(~Season) +               # divido in quattro box
  coord_cartesian(ylim = c(0, 10)) +  # taglio alcuni valori estremi
  theme_bw()

```

Scatterplot che mette tre variabili a confronto...

```{r}
StationData %>% 
  filter(
    wndSpeed >= 0, 
    outHum >=0, 
    outTemp > -50,
    inTemp > 0,
    totRad >=0
  ) %>% 
  ggplot(aes(totRad, outHum-inHum, color = outTemp-inTemp)) +
  geom_count() +
  facet_wrap(~Season) +
  scale_color_gradient2() + 
  # coord_cartesian(xlim = c(0,100)) + 
  # coord_fixed(
  #   xlim=c(0,20),
  #   ylim=c(0,20)
  #   ) +
  theme_bw()

```

### 

------------------------------------------------------------------------

### Filtri

Tramite la funzione `filter()` del pacchetto `dplyr` (sempre di tidyverse) posso creare filtri ponendo condizioni direttamente sulle colonne del dataset originale.

Tramite la funzione `minute()` del pacchetto `lubridate()` seleziono solo le righe prese allo scadere dell'ora.

Salvo un sottoinsieme del dataset in una nuova variabile, raccogliendo solo i dati orari. Attenzione perché la variabile "Interval" rimane impostata sulla risoluzione temporale originaria. Voglio solo misure orarie provenienti dalle letture ogni 30 minuti quindi richiedo anche che Interval == 30.

```{r}
HourlyData <- StationData %>%
  filter(
    minute(DateTime) == 0,
    Interval == 30
  )

print(HourlyData)
```

Per salvare il dataset di tutte le righe escluse posso usare nuovamente filter stando attento di impostare i filtri in modo complementare, oppure posso usare la funzione `setdiff()` di `dplyr`. Dichiaro l'appartenenza al pacchetto in modo esplicito per essere sicuro che non ci siano ambiguità nel caso di più funzioni con lo stesso nome.

```{r}
excludedData <- dplyr::setdiff(StationData, HourlyData)
print(excludedData)
```


Filtro i valori non verosimili della velocità del vento.

```{r}
windData <- StationData %>%
  filter(
    Interval == 30, # seleziono solo misure a 30 minuti
    
    wndSpeed >= 0,
    wndSpeed <= 25,
    
    wndDir >= 0,
    wndDir <= 360
    
  )%>%
  select(DateTime, wndDir, wndSpeed)

print(windData)
```


Elimino gli istanti in cui il vento non è nullo ma non cambia per tre ore consecutive (indice di malfunzionamento).
```{r}
# Voglio creare intanto un flag di continuità delle tre ore:
Diff3h <- c(rep(NA, 5), diff(windData$DateTime,lag = 5))
windData$whole3hours <- Diff3h == 2.5

# poi cerco le righe in cui le velocità non cambiano per 5 intervalli, pur diverse da zero
windData$constFlag <- rep(FALSE, length(windData$DateTime))
for(i in 6:length(windData$DateTime)){
  if(
    all(!is.na(windData$whole3hours[i-5:i])) &
    all(windData$whole3hours[i-5:i]) &
    length(unique(windData$wndSpeed[i-5:i])) == 1
  ){
    windData$constFlag[i-5:i] <- T
  }
}
# molto lenta, riscrivere con rollapply()

windData %>% filter(
  wndSpeed > 0,
  constFlag == T,
  whole3hours == T
) %>% print()

```

